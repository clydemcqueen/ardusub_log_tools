#!/usr/bin/env python3

"""
Generate a folium map from the log generated by wl_ugps_logger.py.
"""

import argparse
import math
from argparse import ArgumentParser
from typing import NamedTuple

import folium
import pandas as pd

import util
from map_maker import MapMaker


# A sonar receiver
class Receiver(NamedTuple):
    field: str
    description: str
    color: str


# Note that the UI counts receivers starting at 1, but the field names start at 0
# WL UGPS reference frames: https://waterlinked.github.io/underwater-gps/reference-frames/
# WL UGPS antenna diagram: # https://waterlinked.github.io/underwater-gps/antenna/
RECEIVERS = [
    Receiver('valid_r0', 'missing R1, -x, aft', 'red'),
    Receiver('valid_r1', 'missing R2, +y, starboard', 'black'),
    Receiver('valid_r2', 'missing R3, +x, forward', 'green'),
    Receiver('valid_r3', 'missing R4, 0, center', 'blue'),
]


# The antenna location
class Antenna(NamedTuple):
    lat: float
    lon: float
    heading_deg: float

    def heading_rad(self):
        return math.radians(self.heading_deg)


# Antenna location for Seattle Aquarium diver ramp tests
SEAQ_ANTENNA = Antenna(47.6075779801547, -122.34390446166833, -90)

# Antenna location for Bell Harbor dock tests
BH_ANTENNA = Antenna(47.610146, -122.347964, -45)

# Default antenna location
DEFAULT_ANTENNA = SEAQ_ANTENNA

# Verify that this is a csv file generated by wl_ugps.logger.py
# x == Forward
# y == Right
REQUIRED_FIELDS = [
    'position_valid',
    'std',
    'x',
    'y',
    'z',
    'distance_r0',
    'distance_r1',
    'distance_r2',
    'distance_r3',
    'nsd_r0',
    'nsd_r1',
    'nsd_r2',
    'nsd_r3',
    'rssi_r0',
    'rssi_r1',
    'rssi_r2',
    'rssi_r3',
    RECEIVERS[0].field,
    RECEIVERS[1].field,
    RECEIVERS[2].field,
    RECEIVERS[3].field,
    'timestamp',
]

# Radius of the Earth
EARTH_RADIUS_M = 6378000


def lat_plus_dist(lat, d):
    return lat + (d / EARTH_RADIUS_M) * (180.0 / math.pi)


def lon_plus_dist(lat, lon, d):
    return lon + (d / EARTH_RADIUS_M) * (180 / math.pi) / math.cos(lat * math.pi / 180.0)


def rotate_x(x, y, a):
    return math.cos(a) * x - math.sin(a) * y


def rotate_y(x, y, a):
    return math.sin(a) * x + math.cos(a) * y


# If one of the transducers has a poor signal, return a marker
def marker_function(row) -> folium.CircleMarker | None:
    for r in RECEIVERS:
        if row[r.field] == 0:
            return folium.CircleMarker((row['lat'], row['lon']), tooltip=r.description, radius=5, color=r.color)
    return None


def process_wl_log(infile: str, antenna: Antenna, zoom: int):
    # Read csv file, don't crash
    try:
        df = pd.read_csv(infile)
    except Exception as e:
        print(f'Exception parsing csv file: {e}')
        return

    for field in REQUIRED_FIELDS:
        if field not in df.columns:
            print(f'Required field [{field}] missing, skipping')
            return

    num_rows = len(df)
    start = df.head(1)['timestamp'][0]
    stop = df.tail(1)['timestamp'][num_rows - 1]
    duration = stop - start
    frequency = num_rows / duration
    print(f'Log contains {num_rows} rows spanning {duration :.1f} seconds recorded at {frequency :.1f} Hz')

    # Filter out rows where 'position_valid' is False
    df = df[df['position_valid'] == True]

    if len(df) == 0:
        print('No valid rows, skipping')
        return

    num_removed = num_rows - len(df)
    print(f'Removed {num_removed} rows ({num_removed * 100.0 / num_rows :.0f}%) where position_valid == False')

    print(f'Rotating by {antenna.heading_deg} degrees')
    heading_rad = antenna.heading_rad()
    df['rot_x'] = df.apply(lambda row: rotate_x(row.x, row.y, heading_rad), axis=1)
    df['rot_y'] = df.apply(lambda row: rotate_y(row.x, row.y, heading_rad), axis=1)

    print(f'Translating by ({antenna.lat}, {antenna.lon})')
    df['lat'] = df.apply(lambda row: lat_plus_dist(antenna.lat, row.rot_x), axis=1)
    df['lon'] = df.apply(lambda row: lon_plus_dist(antenna.lat, antenna.lon, row.rot_y), axis=1)

    # Count rows where one receiver did not receive a valid signal
    num_partially_valid_rows = 0
    for r in RECEIVERS:
        num_missing_receiver = len(df[df[r.field] == 0])
        print(f'Draw {num_missing_receiver} {r.color} circles(s) for {r.description}')
        num_partially_valid_rows += num_missing_receiver

    print(f'{num_partially_valid_rows} rows ({num_partially_valid_rows * 100.0 / num_rows :.0f}%) are missing a signal')

    # Generate map
    mm = MapMaker(False, [df['lat'].mean(), df['lon'].mean()], zoom)
    mm.add_df(df, 'lat', 'lon', 'black', marker_function)
    mm.write(util.get_outfile_name(infile, ext='.html'))


def main():
    parser = ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, description=__doc__)
    parser.add_argument('-r', '--recurse', action='store_true',
                        help='enter directories looking for csv files')
    parser.add_argument('--lat', default=DEFAULT_ANTENNA.lat, type=float,
                        help='WL UGPS antenna latitude')
    parser.add_argument('--lon', default=DEFAULT_ANTENNA.lon, type=float,
                        help='WL UGPS antenna longitude')
    parser.add_argument('--heading', default=DEFAULT_ANTENNA.heading_deg, type=float,
                        help='WL UGPS antenna heading')
    parser.add_argument('--zoom', default=18, type=int,
                        help='initial zoom, default is 18')
    parser.add_argument('path', nargs='+')
    args = parser.parse_args()
    files = util.expand_path(args.path, args.recurse, '.csv')
    print(f'Processing {len(files)} files')

    for infile in files:
        print('-------------------')
        print(infile)
        process_wl_log(infile, Antenna(args.lat, args.lon, args.heading), args.zoom)


if __name__ == '__main__':
    main()
